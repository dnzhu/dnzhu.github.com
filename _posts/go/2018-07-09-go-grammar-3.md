---
layout: post
title: "go并发"
description: ""
category: go
tags: [go]
---

### 使用goroutine 运行程序

#### 并发与并行

    并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。

```
package main

import (
    "fmt"
    "runtime"
    "sync"
)
func main() {
    // 分配1个逻辑处理器给调度器使用
    runtime.GOMAXPROCS(1)
    // 申明一个wg用来等待程序完成
    var wg sync.WaitGroup
    // 计数加 2，表示要等待两个goroutine
    wg.Add(2)
    fmt.Println("START\n")
    //声明一个匿名函数，并创建一个goroutine
    go func() {
        for count := 0; count < 3; count++ {
            for cha := 'a'; cha < 'a'+26; cha++ {
                fmt.Printf("%c ", cha)
            }
        }
        defer wg.Done()
    }()

    //声明一个匿名函数，并创建一个goroutine
    go func() {

        for count := 0; count < 3; count++ {
            for char := 'A'; char < 'A'+26; char++ {
                fmt.Printf("%c ", char)
            }
        }
        //在函数退出时调用Done 来通知main函数工作已经完成
        defer wg.Done()
    }()
    fmt.Printf("gorunning finished \n")
    wg.Wait()  //等待goroutine结束
    fmt.Printf("end\n")
}
```

### 检测并修正竞争状态

#### 竞争状态

#### 锁住共享资源

    Go语言提供了传统的同步goroutine的机制，就是对共享资源加锁。如果需要顺序访问一个整型变量或者一段代码，atomic 和sync 包里的函数提供了解决方案。

### 利用通道共享数据

```
package main

import (
    "fmt"
    "runtime"
    "sync"
    "sync/atomic"
)

var (
    counter int64
    wg      sync.WaitGroup
)

func incCounter(u int64) {
    defer wg.Done()
    for count := 0; count < 2; count++ {
        atomic.AddInt64(&counter, u)
        runtime.Gosched()  //从线程退出到队列中
    }
}

func main() {
    wg.Add(2)
    go incCounter(1)
    go incCounter(2)
    wg.Wait()
    fmt.Println("counter:", counter)
}
```